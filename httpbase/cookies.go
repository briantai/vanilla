// This file is Copyright 2015 Matt Silverlock (matt@eatsleeprepeat.net).  All rights reserved.
// Use of this source code is governed by a BSD style license.
//
// Modifications by Kevin Stenerson for Reflexion Health Inc. Copyright 2015
package httpbase

import (
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"net/http"
	"net/url"
	"time"

	"github.com/gorilla/securecookie"
	"github.com/reflexionhealth/vanilla/router"
)

const (
	CookieRealToken = "SIGNED-TOKEN"
	CookieXSRFToken = "XSRF-TOKEN"
	HeaderXSRFToken = "X-XSRF-Token"

	LocalCookies = "Cookies"

	xsrfTokenLength  = 32
	xsrfTokenExpires = 3600
)

var safeMethods = []string{"GET", "HEAD", "OPTIONS", "TRACE"}

// MustEncryptCookie sets a cookie value for a secure session
func MustEncryptCookie(c *router.Context, maxAge int, name string, value interface{}) {
	cookieJar := c.MustGetLocal(LocalCookies).(*securecookie.SecureCookie)
	encoded, err := cookieJar.Encode(CookieRealToken, value)
	if err != nil {
		panic(err)
	}

	cookie := http.Cookie{Name: name, Value: encoded, HttpOnly: true, Secure: true}
	if maxAge > 0 {
		cookie.Expires = time.Now().Add(time.Duration(maxAge) * time.Second)
	} else if maxAge < 0 {
		cookie.Expires = time.Unix(1, 0) // expires now
	}

	http.SetCookie(c.Response, &cookie)
}

// ProtectCookies provides cookie storage with XSRF Protection
func ProtectCookies(key []byte) router.HandlerFunc {
	if len(key) != 96 {
		panic("key must be 96 bytes")
	}

	cookieJar := securecookie.New(key[:64], key[64:])
	return func(c *router.Context) {
		c.SetLocal(LocalCookies, cookieJar)

		// get or create token
		var realToken []byte
		tokenCookie, err := c.Request.Cookie(CookieRealToken)
		if err == nil {
			err = cookieJar.Decode(CookieRealToken, tokenCookie.Value, &realToken)
		}

		// if either Cookie() or Decode() failed
		if err != nil || len(realToken) != xsrfTokenLength {
			realToken, err = randomBytes(xsrfTokenLength)
			MustEncryptCookie(c, 0, CookieRealToken, realToken)
		}

		// set the new xsrf token
		nextCookie := http.Cookie{Name: CookieXSRFToken, Value: maskToken(realToken), HttpOnly: true, Secure: true}
		http.SetCookie(c.Response, &nextCookie)

		// if its not a safe method, check the XSRF-TOKEN
		if !contains(safeMethods, c.Request.Method) {
			if c.Request.URL.Scheme == "https" {
				referer, err := url.Parse(c.Request.Referer())
				if err != nil || referer.String() == "" {
					Error(&c.Response, 403, "Referer is missing in protected request")
					return
				}

				if !sameOrigin(c.Request.URL, referer) {
					Error(&c.Response, 403, "Referer does not match Origin in protected request")
					return
				}
			}

			requestToken := unmaskToken(c.Request.Header.Get(HeaderXSRFToken))
			if !sameToken(requestToken, realToken) {
				Error(&c.Response, 403, "XSRF Token does not match in protected request")
				return
			}
		}

		// set the Vary: Cookie header to protect clients from caching the response
		c.Response.Header().Add("Vary", "Cookie")

		c.Continue()
	}
}

// sameOrigin returns true if URLs a and b share the same origin.
// The same origin is defined as host (which includes the port) and scheme.
func sameOrigin(a, b *url.URL) bool {
	return (a.Scheme == b.Scheme && a.Host == b.Host)
}

// compare securely (constant-time) an unmasked token with the real token
func sameToken(a, b []byte) bool {
	return subtle.ConstantTimeCompare(a, b) == 1
}

// maskToken returns a unique-per-request token to mitigate the BREACH attack
// as per http://breachattack.com/#mitigations
//
// The token is generated by XOR'ing a one-time-pad and the base (session) XSRF token
// and returning them together as a 64-byte slice. This effectively randomises the
// token on a per-request basis without breaking multiple browser tabs/windows.
func maskToken(realToken []byte) string {
	otp, err := randomBytes(xsrfTokenLength)
	if err != nil {
		return ""
	}

	return base64.StdEncoding.EncodeToString(append(otp, xorToken(otp, realToken)...))
}

// unmaskToken splits the issued token (one-time-pad + masked token) and returns it unmasked
func unmaskToken(requestToken string) []byte {
	issued, err := base64.StdEncoding.DecodeString(requestToken)
	if err != nil || len(issued) != xsrfTokenLength*2 {
		return nil
	}

	otp := issued[xsrfTokenLength:]
	masked := issued[:xsrfTokenLength]
	return xorToken(otp, masked)
}

// xorToken XORs tokens ([]byte) to provide unique-per-request XSRF tokens
func xorToken(a, b []byte) []byte {
	n := len(a)
	if len(b) < n {
		n = len(b)
	}

	res := make([]byte, n)

	for i := 0; i < n; i++ {
		res[i] = a[i] ^ b[i]
	}

	return res
}

// contains is a helper function to check if a string exists in a slice
func contains(vals []string, s string) bool {
	for _, v := range vals {
		if v == s {
			return true
		}
	}

	return false
}

// randomBytes returns securely generated random bytes.
// It will return an error if the secure random generator fails.
func randomBytes(n int) ([]byte, error) {
	b := make([]byte, n)

	// err will be nil only if len(b) == n
	_, err := rand.Read(b)
	if err != nil {
		return nil, err
	}

	return b, nil
}
